# === Arborescence du dossier ===

TODO - CLI
├── cli unique.md
├── commandes_prevues.md
├── helpers_commandes.md
├── pipeline-amelioree.json
├── pipeline_json.md
└── sidecar file for metadata.md


# === Contenu des fichiers ===

--- Fichier : cli unique.md ---



### Fichier : cli_unique.md

Voici le rapport mis à jour avec la suppression de la commande `index` et l’ajout d’une section conceptuelle sur le support des pipelines JSON.

---

**Rapport — Spécification conceptuelle de l’interface CLI de `hash-tool` (version mise à jour)**

**1. Objectif général**

Le logiciel `hash-tool` propose une interface en ligne de commande unique, indépendante du mode d’exécution réel (natif ou conteneurisé). L’utilisateur interagit exclusivement avec une grammaire de commandes stable, sans référence explicite à l’environnement d’exécution. Le logiciel choisit automatiquement le mode d’exécution (natif ou conteneurisé) selon les capacités détectées.

Ce principe correspond à une abstraction de la couche d’exécution : la CLI constitue un contrat stable entre l’utilisateur et le logiciel, tandis que l’implémentation peut varier selon l’environnement.

---

**2. Principe d’interface de commande unique**

La propriété centrale reste l’« unicité de l’interface » :

– L’utilisateur invoque toujours `hash-tool` avec la même syntaxe,
– Le logiciel détecte en interne les capacités de l’environnement,
– Si l’exécution native est possible, elle est utilisée,
– Sinon, le programme délègue l’exécution à un conteneur (Docker), invisible pour l’utilisateur.

Docker ou tout autre conteneur devient un **détail d’implémentation**. La CLI reste stable et intuitive.

---

**3. Support des pipelines JSON (conceptuel)**

Le logiciel prend en charge un **fichier pipeline JSON** définissant une suite d’opérations à exécuter automatiquement. Chaque opération (`op`) correspond à une commande CLI (`compute`, `verify`, `compare`). Le runner (`hash-tool runner -pipeline <chemin>`) parcourt le JSON et exécute chaque étape dans l’ordre, en respectant la logique métier.

Exemple conceptuel :

```json
{
  "pipeline": [
    { "op": "compute", "source": "...", "bases": "...", "nom": "..." },
    { "op": "verify", "source": "...", "base": "..." },
    { "op": "compare", "base_a": "...", "base_b": "...", "resultats": "..." }
  ]
}
```

**Description fonctionnelle :**

– Les chemins et noms dans le JSON reflètent les arguments de la CLI.
– Les opérations sont cumulables et répétables sur plusieurs dossiers et bases sans intervention manuelle.
– Cette approche rend la CLI plus puissante et adaptée à l’automatisation tout en conservant l’interface unique et cohérente.

---

**4. Conclusion**

Le modèle CLI conceptuel final :

– Interface homogène et stable pour toutes les opérations,
– Détection automatique du mode d’exécution (natif ou Docker),
– Support conceptuel des pipelines JSON pour automatisation,
– Détail d’implémentation masqué à l’utilisateur,
– Maximisation de lisibilité, portabilité et ergonomie.




--- Fichier : commandes_prevues.md ---


### Fichier : commandes_prevues.md

**Rapport — Commandes prévues de `hash-tool`**

---

**1. Principe général**

Toutes les commandes suivent le schéma unique :

```
hash-tool <commande> [options]
```

L’utilisateur n’a pas besoin de connaître le mode d’exécution (natif ou Docker), qui est détecté automatiquement.

---

**2. Commandes principales et usage rapide**

| Commande    | Description courte                                                 |
| ----------- | ------------------------------------------------------------------ |
| `compute`   | Calcule les empreintes des fichiers d’un dossier.                  |
| `verify`    | Vérifie l’intégrité d’un dossier à partir d’une base d’empreintes. |
| `compare`   | Compare deux bases d’empreintes (snapshots).                       |
| `runner`    | Exécute un pipeline défini dans un fichier JSON.                   |
| `list`      | Liste les bases d’empreintes disponibles dans un dossier.          |
| `diff`      | Affiche les différences entre une base et un dossier courant.      |
| `stats`     | Affiche des statistiques sur une base d’empreintes.                |
| `check-env` | Analyse l’environnement d’exécution (natif ou conteneur).          |
| `version`   | Affiche la version du logiciel.                                    |
| `help`      | Affiche le help global ou spécifique à une commande.               |

---

**3. Options génériques principales**

| Option               | Description                                                            |
| -------------------- | ---------------------------------------------------------------------- |
| `-data <chemin>`     | Chemin vers le dossier de données à analyser.                          |
| `-base <chemin>`     | Chemin vers un fichier base d’empreintes (.b3) ou un dossier de bases. |
| `-old <chemin>`      | Chemin vers l’ancienne base (pour `compare`).                          |
| `-new <chemin>`      | Chemin vers la nouvelle base (pour `compare`).                         |
| `-pipeline <chemin>` | Chemin vers un fichier pipeline JSON.                                  |
| `-save <chemin>`     | Dossier de sortie pour les résultats.                                  |
| `-readonly`          | Force l’ouverture des données en lecture seule.                        |
| `-verbose`           | Mode verbeux.                                                          |
| `-quiet`             | Mode silencieux.                                                       |
| `-help`              | Affiche le help spécifique.                                            |
| `-version`           | Affiche la version.                                                    |

---

**4. Exemples d’utilisation rapide**

```bash
# Calculer les empreintes d’un dossier
hash-tool compute -data ./donnees -save ./bases

# Vérifier l’intégrité d’un dossier à partir d’une base
hash-tool verify -data ./donnees -base ./bases/hashes.b3 -save ./resultats

# Comparer deux bases
hash-tool compare -old ancien.b3 -new nouveau.b3 -save ./resultats

# Exécuter un pipeline JSON
hash-tool runner -pipeline ./pipeline.json -save ./resultats

# Vérifier l’environnement
hash-tool check-env
```

---

**5. Objectif de ce fichier**

* Fournir un **référentiel rapide et clair** des commandes disponibles.
* Permettre à l’utilisateur de comprendre la syntaxe générale sans consulter tous les helps détaillés.
* Complémentaire à `helpers_commandes.md` pour les détails par sous-commande.



--- Fichier : helpers_commandes.md ---

### Fichier : helpers_commandes.md

**Rapport — Helps spécifiques des sous-commandes de `hash-tool`**

---

### 1. Help global

```bash
hash-tool help
```

**Usage :**
`hash-tool <commande> [options]`

**Commandes principales :**

* `compute`        Calcule les empreintes d’un dossier.
* `verify`         Vérifie l’intégrité d’un dossier à partir d’une base.
* `compare`        Compare deux bases d’empreintes.
* `runner`         Exécute un pipeline JSON.
* `list`           Liste les bases d’empreintes disponibles.
* `diff`           Affiche les différences entre une base et un dossier.
* `stats`          Affiche des statistiques sur une base.
* `check-env`      Analyse l’environnement d’exécution.
* `version`        Affiche la version.
* `help`           Affiche cette aide.

**Options générales :**

* `-data <chemin>`        Dossier à analyser.
* `-base <chemin>`        Fichier base d’empreintes (.b3).
* `-old <chemin>`         Ancienne base (pour `compare`).
* `-new <chemin>`         Nouvelle base (pour `compare`).
* `-pipeline <chemin>`    Fichier pipeline JSON.
* `-save <chemin>`        Dossier de sortie pour les résultats.
* `-readonly`             Lecture seule.
* `-verbose`              Mode verbeux.
* `-quiet`                Mode silencieux.
* `-help`                 Affiche le help spécifique.
* `-version`              Affiche la version.

---

### 2. Helps spécifiques par sous-commande

#### 2.1 Compute

```bash
hash-tool compute -help
```

**Usage :**
`hash-tool compute -data <chemin dossier> -save <chemin sortie> [options]`

**Options :**

* `-data <chemin>`      Dossier contenant les fichiers à hacher.
* `-save <chemin>`      Dossier où enregistrer la base d’empreintes.
* `-verbose`            Mode verbeux.
* `-readonly`           Analyse en lecture seule.
* `-quiet`              Mode silencieux.

**Exemple :**
`hash-tool compute -data ./donnees -save ./bases`

---

#### 2.2 Verify

```bash
hash-tool verify -help
```

**Usage :**
`hash-tool verify -data <chemin dossier> -base <chemin base.b3> -save <chemin sortie> [options]`

**Options :**

* `-data <chemin>`      Dossier à vérifier.
* `-base <chemin>`      Base d’empreintes de référence.
* `-save <chemin>`      Dossier de sortie pour le rapport de vérification.
* `-verbose`            Mode verbeux.
* `-quiet`              Mode silencieux.

**Exemple :**
`hash-tool verify -data ./donnees -base ./bases/hashes.b3 -save ./resultats`

---

#### 2.3 Compare

```bash
hash-tool compare -help
```

**Usage :**
`hash-tool compare -old <chemin ancien.b3> -new <chemin nouveau.b3> -save <chemin sortie> [options]`

**Options :**

* `-old <chemin>`       Ancienne base d’empreintes.
* `-new <chemin>`       Nouvelle base d’empreintes.
* `-save <chemin>`      Dossier de sortie pour le rapport de comparaison.
* `-verbose`            Mode verbeux.
* `-quiet`              Mode silencieux.

**Exemple :**
`hash-tool compare -old ancien.b3 -new nouveau.b3 -save ./resultats`

---

#### 2.4 Runner (pipeline JSON)

```bash
hash-tool runner -help
```

**Usage :**
`hash-tool runner -pipeline <chemin pipeline.json> -save <chemin sortie> [options]`

**Options :**

* `-pipeline <chemin>`  Fichier JSON définissant le pipeline.
* `-save <chemin>`      Dossier de sortie pour les résultats du pipeline.
* `-verbose`            Mode verbeux.
* `-quiet`              Mode silencieux.

**Exemple :**
`hash-tool runner -pipeline ./pipeline.json -save ./resultats`

---

#### 2.5 List

```bash
hash-tool list -help
```

**Usage :**
`hash-tool list -base <chemin dossier> [options]`

**Options :**

* `-base <chemin>`      Dossier contenant les snapshots à lister.
* `-verbose`            Mode verbeux.

**Exemple :**
`hash-tool list -base ./bases`

---

#### 2.6 Diff

```bash
hash-tool diff -help
```

**Usage :**
`hash-tool diff -base <chemin base.b3> -data <chemin dossier> [options]`

**Options :**

* `-base <chemin>`      Base d’empreintes de référence.
* `-data <chemin>`      Dossier à comparer.
* `-verbose`            Mode verbeux.

**Exemple :**
`hash-tool diff -base ./bases/hashes.b3 -data ./donnees`

---

#### 2.7 Stats

```bash
hash-tool stats -help
```

**Usage :**
`hash-tool stats -base <chemin base.b3> [options]`

**Options :**

* `-base <chemin>`      Base d’empreintes pour calculer les statistiques.
* `-verbose`            Mode verbeux.

**Exemple :**
`hash-tool stats -base ./bases/hashes.b3`

---

#### 2.8 Check-env

```bash
hash-tool check-env -help
```

**Usage :**
`hash-tool check-env`

**Description :**
Analyse l’environnement d’exécution et indique si le programme peut s’exécuter nativement ou doit utiliser Docker.

---

#### 2.9 Version

```bash
hash-tool version -help
```

**Usage :**
`hash-tool version`

**Description :**
Affiche la version du logiciel.

---

**3. Conclusion**

* Chaque sous-commande dispose d’un help dédié pour détailler ses options et arguments.
* Le help global résume les commandes principales et sert de point d’entrée.
* Cette structure améliore la lisibilité, l’apprentissage et l’ergonomie, tout en conservant l’interface unique et le masquage de Docker.



--- Fichier : pipeline-amelioree.json ---
{
  "pipeline": [
    {
      "type": "compute",
      "params": {
        "input": "/mnt/data/dossier_exemple",
        "output_dir": "/mnt/bases",
        "filename": "hashes_exemple.b3"
      },
      "options": {
        "verbose": true
      },
      "description": "Calcul des empreintes pour un dossier exemple"
    },
    {
      "type": "verify",
      "params": {
        "input": "/mnt/data/dossier_exemple",
        "reference": "/mnt/bases/hashes_exemple.b3",
        "output_dir": "/mnt/resultats/verify_exemple"
      },
      "options": {},
      "description": "Vérification de l’intégrité du dossier exemple"
    },
    {
      "type": "compare",
      "params": {
        "input": "/mnt/bases/hashes_exemple.b3",
        "reference": "/mnt/bases/hashes_autre.b3",
        "output_dir": "/mnt/resultats/compare_exemple"
      },
      "options": {},
      "description": "Comparaison de deux bases d’empreintes"
    },
    {
      "type": "runner",
      "params": {
        "pipeline_file": "/mnt/pipelines/pipeline_secondaire.json",
        "output_dir": "/mnt/resultats/runner_exemple"
      },
      "options": {
        "verbose": true
      },
      "description": "Exécution d’un pipeline JSON secondaire"
    },
    {
      "type": "list",
      "params": {
        "input_dir": "/mnt/bases"
      },
      "options": {},
      "description": "Lister les bases d’empreintes disponibles"
    },
    {
      "type": "diff",
      "params": {
        "input": "/mnt/bases/hashes_exemple.b3",
        "reference_dir": "/mnt/data/dossier_exemple"
      },
      "options": {},
      "description": "Afficher les différences entre la base et le dossier"
    },
    {
      "type": "stats",
      "params": {
        "input": "/mnt/bases/hashes_exemple.b3"
      },
      "options": {},
      "description": "Afficher les statistiques de la base d’empreintes"
    },
    {
      "type": "check-env",
      "params": {},
      "options": {},
      "description": "Vérifier si l’exécution native ou Docker est possible"
    },
    {
      "type": "version",
      "params": {},
      "options": {},
      "description": "Afficher la version du logiciel"
    }
  ]
}

--- Fichier : pipeline_json.md ---



### Fichier : pipeline_json.md

**Rapport — Documentation du pipeline JSON pour `hash-tool`**

---

**1. Objectif**

Le pipeline JSON permet de définir une suite d’opérations à exécuter automatiquement avec `hash-tool runner`. Chaque opération correspond à une commande CLI (`compute`, `verify`, `compare`, etc.) et inclut les chemins et paramètres nécessaires.

Le fichier `pipeline-amelioree.json` fournit un exemple représentatif, suffisamment descriptif pour couvrir toutes les commandes principales et illustrer la structure uniforme du pipeline.

---

**2. Structure générale**

Le pipeline utilise une structure uniforme pour toutes les étapes :

* `type` : commande à exécuter (`compute`, `verify`, `compare`, `runner`, `list`, `diff`, `stats`, `check-env`, `version`).
* `params` : arguments spécifiques à la commande (`input`, `reference`, `output_dir`, etc.).
* `options` : flags optionnels (`verbose`, `quiet`, `readonly`, etc.).
* `description` : texte explicatif décrivant l’étape.

Cette structure permet au runner de **parcourir toutes les étapes dans l’ordre** et d’exécuter automatiquement les commandes, tout en conservant un format homogène et facile à valider.

---

**3. Référence du fichier pipeline**

Le pipeline détaillé est disponible dans le fichier :

```
pipeline-amelioree.json
```

Ce fichier contient un exemple réduit mais représentatif, couvrant toutes les commandes principales et utilisant la structure uniforme `type` / `params` / `options` avec descriptions.

---

**4. Description fonctionnelle**

* Chaque étape du tableau correspond à une commande CLI.
* Les champs `params` et `options` sont uniformes pour toutes les commandes.
* Le champ `description` permet de documenter le pipeline directement dans le JSON.
* Le runner parcourt les étapes dans l’ordre et exécute chaque commande automatiquement.

---

**5. Bonnes pratiques**

1. Toujours vérifier les chemins et permissions avant exécution.
2. Utiliser des noms explicites pour les fichiers de base (`filename`) et dossiers de sortie (`output_dir`).
3. Ajouter les options (`verbose`, `quiet`, `readonly`) au niveau de chaque étape si nécessaire.
4. Compléter le champ `description` pour documenter le rôle de chaque étape, ce qui facilite l’automatisation et la compréhension du pipeline.
5. Utiliser le fichier `pipeline-amelioree.json` comme référence pour créer de nouveaux pipelines cohérents.

---

**6. Avantages du format réduit**

* Pertinent et compréhensible pour l’utilisateur.
* Suffisamment descriptif pour illustrer toutes les commandes principales.
* Uniforme, extensible et facile à valider avec JSON Schema.
* Permet l’automatisation et la documentation simultanément.




--- Fichier : sidecar file for metadata.md ---



### Note — Feature « Sidecar File » pour `hash-tool`

**Objet :** ajout de la possibilité de stocker des métadonnées et commentaires associés aux fichiers `.b3` générés par `hash-tool`.

---

#### 1. Contexte

Les fichiers `.b3` générés par `hash-tool` contiennent uniquement les hash Blake3 des fichiers d’un dossier. Actuellement, il n’existe aucun espace prévu pour des commentaires ou des informations complémentaires (ex. date de snapshot, paramètres utilisés, version de l’outil).

Pour enrichir l’information sans modifier le format `.b3` natif ni perdre la compatibilité avec d’autres outils Blake3, l’introduction d’un **sidecar file** est proposée.

---

#### 2. Principe

Un **sidecar file** est un fichier annexe, créé à côté du fichier `.b3` correspondant, contenant des métadonnées structurées.

* Extension suggérée : `.meta.json` ou `.b3.json` (ex. `hashes_exemple.b3.meta.json`).
* Format : JSON, pour lisibilité et compatibilité avec les pipelines existants.
* Contenu typique : informations descriptives, date de création, paramètres d’exécution, version de `hash-tool`.

---

#### 3. Structure du sidecar

Exemple minimal de fichier sidecar :

```json
{
  "created_by": "hash-tool v1.2",
  "date": "2026-02-24T14:30:00Z",
  "comment": "Snapshot avant migration",
  "parameters": {
    "readonly": true,
    "directory": "/mnt/data/dossier_exemple",
    "hash_algo": "blake3"
  }
}
```

**Champs principaux :**

| Champ        | Description                                                                   |
| ------------ | ----------------------------------------------------------------------------- |
| `created_by` | Version de l’outil ayant généré le snapshot.                                  |
| `date`       | Date et heure du calcul des hash.                                             |
| `comment`    | Texte libre pour des informations contextuelles.                              |
| `parameters` | Paramètres utilisés pour le calcul des hash (répertoires, flags, algorithme). |

---

#### 4. Avantages

1. **Compatibilité** : le fichier `.b3` reste inchangé, donc compatible avec Blake3 standard.
2. **Extensible** : possibilité d’ajouter de nouveaux champs sans modifier le moteur de hash.
3. **Synchronisation** : le sidecar est lié au fichier `.b3` correspondant et peut être automatiquement créé par `hash-tool`.
4. **Automatisation** : les pipelines (`runner`) peuvent lire et utiliser les métadonnées pour documentation ou suivi.

---

#### 5. Intégration dans `hash-tool`

* **Création automatique** : lors de `hash-tool compute`, un sidecar peut être généré dans le même répertoire que le `.b3`.
* **Lecture et affichage** : les commandes `verify`, `compare`, `stats` peuvent afficher ou exploiter les métadonnées.
* **Mise à jour optionnelle** : possibilité d’ajouter un commentaire postérieur au snapshot sans toucher au `.b3`.

**Exemple d’usage :**

```bash
hash-tool compute -data ./donnees -save ./bases --with-meta "Snapshot initial"
```

Cette commande générerait :

* `hashes_donnees.b3` → hash des fichiers
* `hashes_donnees.b3.meta.json` → métadonnées contenant la note “Snapshot initial” et autres informations automatiques (date, version, paramètres).

---

#### 6. Conclusion

Le sidecar file est une solution simple et robuste pour enrichir les fichiers `.b3` avec des métadonnées :

* Aucun impact sur le format binaire existant.
* Permet la documentation, l’automatisation et le suivi des snapshots.
* Compatible avec les pipelines et l’interface CLI unique de `hash-tool`.


